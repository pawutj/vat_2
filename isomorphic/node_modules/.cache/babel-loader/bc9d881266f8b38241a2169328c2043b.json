{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Utils = require('../core/Utils');\n\nvar Translator = require('../core/Translator');\n\nvar UppySocket = require('./UppySocket');\n\nvar ee = require('namespace-emitter');\n\nvar cuid = require('cuid');\n\nvar throttle = require('lodash.throttle');\n\nvar prettyBytes = require('prettier-bytes');\n\nvar match = require('mime-match' // const en_US = require('../locales/en_US')\n// const deepFreeze = require('deep-freeze-strict')\n\n/**\n * Main Uppy core\n *\n * @param {object} opts general options, like locales, to show modal or not to show\n */\n);\n\nvar Uppy = function () {\n  function Uppy(opts) {\n    _classCallCheck(this, Uppy);\n\n    var defaultLocale = {\n      strings: {\n        youCanOnlyUploadX: {\n          0: 'You can only upload %{smart_count} file',\n          1: 'You can only upload %{smart_count} files'\n        },\n        youHaveToAtLeastSelectX: {\n          0: 'You have to select at least %{smart_count} file',\n          1: 'You have to select at least %{smart_count} files'\n        },\n        exceedsSize: 'This file exceeds maximum allowed size of',\n        youCanOnlyUploadFileTypes: 'You can only upload:',\n        uppyServerError: 'Connection with Uppy server failed' // set default options\n\n      }\n    };\n    var defaultOptions = {\n      autoProceed: true,\n      debug: false,\n      restrictions: {\n        maxFileSize: false,\n        maxNumberOfFiles: false,\n        minNumberOfFiles: false,\n        allowedFileTypes: false\n      },\n      onBeforeFileAdded: function onBeforeFileAdded(currentFile, files) {\n        return Promise.resolve();\n      },\n      onBeforeUpload: function onBeforeUpload(files, done) {\n        return Promise.resolve();\n      },\n      locale: defaultLocale // Merge default options with the ones set by user\n\n    };\n    this.opts = _extends({}, defaultOptions, opts // // Dictates in what order different plugin types are ran:\n    // this.types = [ 'presetter', 'orchestrator', 'progressindicator',\n    //                 'acquirer', 'modifier', 'uploader', 'presenter', 'debugger']\n    );\n    this.locale = _extends({}, defaultLocale, this.opts.locale);\n    this.locale.strings = _extends({}, defaultLocale.strings, this.opts.locale.strings // i18n\n    );\n    this.translator = new Translator({\n      locale: this.locale\n    });\n    this.i18n = this.translator.translate.bind(this.translator // Container for different types of plugins\n    );\n    this.plugins = {}; // @TODO maybe bindall\n\n    this.translator = new Translator({\n      locale: this.opts.locale\n    });\n    this.i18n = this.translator.translate.bind(this.translator);\n    this.getState = this.getState.bind(this);\n    this.updateMeta = this.updateMeta.bind(this);\n    this.initSocket = this.initSocket.bind(this);\n    this.log = this.log.bind(this);\n    this.addFile = this.addFile.bind(this);\n    this.calculateProgress = this.calculateProgress.bind(this);\n    this.resetProgress = this.resetProgress.bind(this // this.bus = this.emitter = ee()\n    );\n    this.emitter = ee();\n    this.on = this.emitter.on.bind(this.emitter);\n    this.off = this.emitter.off.bind(this.emitter);\n    this.once = this.emitter.once.bind(this.emitter);\n    this.emit = this.emitter.emit.bind(this.emitter);\n    this.preProcessors = [];\n    this.uploaders = [];\n    this.postProcessors = [];\n    this.state = {\n      files: {},\n      capabilities: {\n        resumableUploads: false\n      },\n      totalProgress: 0,\n      meta: _extends({}, this.opts.meta),\n      info: {\n        isHidden: true,\n        type: '',\n        msg: '' // for debugging and testing\n\n      }\n    };\n    this.updateNum = 0;\n\n    if (this.opts.debug) {\n      global.UppyState = this.state;\n      global.uppyLog = ''; // global.UppyAddFile = this.addFile.bind(this)\n\n      global._uppy = this;\n    }\n  }\n  /**\n   * Iterate on all plugins and run `update` on them. Called each time state changes\n   *\n   */\n\n\n  Uppy.prototype.updateAll = function updateAll(state) {\n    var _this = this;\n\n    Object.keys(this.plugins).forEach(function (pluginType) {\n      _this.plugins[pluginType].forEach(function (plugin) {\n        plugin.update(state);\n      });\n    });\n  };\n  /**\n   * Updates state\n   *\n   * @param {newState} object\n   */\n\n\n  Uppy.prototype.setState = function setState(stateUpdate) {\n    var newState = _extends({}, this.state, stateUpdate);\n\n    this.emit('core:state-update', this.state, newState, stateUpdate);\n    this.state = newState;\n    this.updateAll(this.state);\n  };\n  /**\n   * Returns current state\n   *\n   */\n\n\n  Uppy.prototype.getState = function getState() {\n    // use deepFreeze for debugging\n    // return deepFreeze(this.state)\n    return this.state;\n  };\n\n  Uppy.prototype.reset = function reset() {\n    this.emit('core:pause-all');\n    this.emit('core:cancel-all');\n    this.setState({\n      totalProgress: 0\n    });\n  };\n\n  Uppy.prototype.resetProgress = function resetProgress() {\n    var defaultProgress = {\n      percentage: 0,\n      bytesUploaded: 0,\n      uploadComplete: false,\n      uploadStarted: false\n    };\n\n    var files = _extends({}, this.state.files);\n\n    var updatedFiles = {};\n    Object.keys(files).forEach(function (fileID) {\n      var updatedFile = _extends({}, files[fileID]);\n\n      updatedFile.progress = _extends({}, updatedFile.progress, defaultProgress);\n      updatedFiles[fileID] = updatedFile;\n    });\n    console.log(updatedFiles);\n    this.setState({\n      files: updatedFiles,\n      totalProgress: 0\n    });\n  };\n\n  Uppy.prototype.addPreProcessor = function addPreProcessor(fn) {\n    this.preProcessors.push(fn);\n  };\n\n  Uppy.prototype.removePreProcessor = function removePreProcessor(fn) {\n    var i = this.preProcessors.indexOf(fn);\n\n    if (i !== -1) {\n      this.preProcessors.splice(i, 1);\n    }\n  };\n\n  Uppy.prototype.addPostProcessor = function addPostProcessor(fn) {\n    this.postProcessors.push(fn);\n  };\n\n  Uppy.prototype.removePostProcessor = function removePostProcessor(fn) {\n    var i = this.postProcessors.indexOf(fn);\n\n    if (i !== -1) {\n      this.postProcessors.splice(i, 1);\n    }\n  };\n\n  Uppy.prototype.addUploader = function addUploader(fn) {\n    this.uploaders.push(fn);\n  };\n\n  Uppy.prototype.removeUploader = function removeUploader(fn) {\n    var i = this.uploaders.indexOf(fn);\n\n    if (i !== -1) {\n      this.uploaders.splice(i, 1);\n    }\n  };\n\n  Uppy.prototype.setMeta = function setMeta(data) {\n    var newMeta = _extends({}, this.getState().meta, data);\n\n    this.log('Adding metadata:');\n    this.log(data);\n    this.setState({\n      meta: newMeta\n    });\n  };\n\n  Uppy.prototype.updateMeta = function updateMeta(data, fileID) {\n    var updatedFiles = _extends({}, this.getState().files);\n\n    var newMeta = _extends({}, updatedFiles[fileID].meta, data);\n\n    updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {\n      meta: newMeta\n    });\n    this.setState({\n      files: updatedFiles\n    });\n  };\n\n  Uppy.prototype.checkRestrictions = function checkRestrictions(checkMinNumberOfFiles, file, fileType) {\n    var _opts$restrictions = this.opts.restrictions,\n        maxFileSize = _opts$restrictions.maxFileSize,\n        maxNumberOfFiles = _opts$restrictions.maxNumberOfFiles,\n        minNumberOfFiles = _opts$restrictions.minNumberOfFiles,\n        allowedFileTypes = _opts$restrictions.allowedFileTypes;\n\n    if (checkMinNumberOfFiles && minNumberOfFiles) {\n      if (Object.keys(this.state.files).length < minNumberOfFiles) {\n        this.info('' + this.i18n('youHaveToAtLeastSelectX', {\n          smart_count: minNumberOfFiles\n        }), 'error', 5000);\n        return false;\n      }\n\n      return true;\n    }\n\n    if (maxNumberOfFiles) {\n      if (Object.keys(this.state.files).length + 1 > maxNumberOfFiles) {\n        this.info('' + this.i18n('youCanOnlyUploadX', {\n          smart_count: maxNumberOfFiles\n        }), 'error', 5000);\n        return false;\n      }\n    }\n\n    if (allowedFileTypes) {\n      var isCorrectFileType = allowedFileTypes.filter(match(fileType.join('/'))).length > 0;\n\n      if (!isCorrectFileType) {\n        var allowedFileTypesString = allowedFileTypes.join(', ');\n        this.info(this.i18n('youCanOnlyUploadFileTypes') + ' ' + allowedFileTypesString, 'error', 5000);\n        return false;\n      }\n    }\n\n    if (maxFileSize) {\n      if (file.data.size > maxFileSize) {\n        this.info(this.i18n('exceedsSize') + ' ' + prettyBytes(maxFileSize), 'error', 5000);\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Uppy.prototype.addFile = function addFile(file) {\n    var _this2 = this;\n\n    return this.opts.onBeforeFileAdded(file, this.getState().files).catch(function (err) {\n      _this2.info(err, 'error', 5000);\n\n      return Promise.reject('onBeforeFileAdded: ' + err);\n    }).then(function () {\n      return Utils.getFileType(file).then(function (fileType) {\n        var updatedFiles = _extends({}, _this2.state.files);\n\n        var fileName = file.name || 'noname';\n        var fileExtension = Utils.getFileNameAndExtension(fileName)[1];\n        var isRemote = file.isRemote || false;\n        var fileID = Utils.generateFileID(file);\n        var fileTypeGeneral = fileType[0];\n        var fileTypeSpecific = fileType[1];\n        var newFile = {\n          source: file.source || '',\n          id: fileID,\n          name: fileName,\n          extension: fileExtension || '',\n          meta: _extends({}, {\n            name: fileName\n          }, _this2.getState().meta),\n          type: {\n            general: fileTypeGeneral,\n            specific: fileTypeSpecific\n          },\n          data: file.data,\n          progress: {\n            percentage: 0,\n            bytesUploaded: 0,\n            bytesTotal: file.data.size || 0,\n            uploadComplete: false,\n            uploadStarted: false\n          },\n          size: file.data.size || 'N/A',\n          isRemote: isRemote,\n          remote: file.remote || '',\n          preview: file.preview\n        };\n\n        if (Utils.isPreviewSupported(fileTypeSpecific) && !isRemote) {\n          newFile.preview = Utils.getThumbnail(file.data);\n        }\n\n        var isFileAllowed = _this2.checkRestrictions(false, newFile, fileType);\n\n        if (!isFileAllowed) return Promise.reject('File not allowed');\n        updatedFiles[fileID] = newFile;\n\n        _this2.setState({\n          files: updatedFiles\n        });\n\n        _this2.emit('core:file-added', newFile);\n\n        _this2.log('Added file: ' + fileName + ', ' + fileID + ', mime type: ' + fileType);\n\n        if (_this2.opts.autoProceed && !_this2.scheduledAutoProceed) {\n          _this2.scheduledAutoProceed = setTimeout(function () {\n            _this2.scheduledAutoProceed = null;\n\n            _this2.upload().catch(function (err) {\n              console.error(err.stack || err.message || err);\n            });\n          }, 4);\n        }\n      });\n    });\n  };\n  /**\n   * Get a file object.\n   *\n   * @param {string} fileID The ID of the file object to return.\n   */\n\n\n  Uppy.prototype.getFile = function getFile(fileID) {\n    return this.getState().files[fileID];\n  };\n\n  Uppy.prototype.removeFile = function removeFile(fileID) {\n    var updatedFiles = _extends({}, this.getState().files);\n\n    delete updatedFiles[fileID];\n    this.setState({\n      files: updatedFiles\n    });\n    this.calculateTotalProgress();\n    this.emit('core:file-removed', fileID);\n    this.log('Removed file: ' + fileID);\n  };\n\n  Uppy.prototype.calculateProgress = function calculateProgress(data) {\n    var fileID = data.id;\n\n    var updatedFiles = _extends({}, this.getState().files // skip progress event for a file that’s been removed\n    );\n\n    if (!updatedFiles[fileID]) {\n      this.log('Trying to set progress for a file that’s not with us anymore: ', fileID);\n      return;\n    }\n\n    var updatedFile = _extends({}, updatedFiles[fileID], _extends({}, {\n      progress: _extends({}, updatedFiles[fileID].progress, {\n        bytesUploaded: data.bytesUploaded,\n        bytesTotal: data.bytesTotal,\n        percentage: Math.floor((data.bytesUploaded / data.bytesTotal * 100).toFixed(2))\n      })\n    }));\n\n    updatedFiles[data.id] = updatedFile;\n    this.setState({\n      files: updatedFiles\n    });\n    this.calculateTotalProgress();\n  };\n\n  Uppy.prototype.calculateTotalProgress = function calculateTotalProgress() {\n    // calculate total progress, using the number of files currently uploading,\n    // multiplied by 100 and the summ of individual progress of each file\n    var files = _extends({}, this.getState().files);\n\n    var inProgress = Object.keys(files).filter(function (file) {\n      return files[file].progress.uploadStarted;\n    });\n    var progressMax = inProgress.length * 100;\n    var progressAll = 0;\n    inProgress.forEach(function (file) {\n      progressAll = progressAll + files[file].progress.percentage;\n    });\n    var totalProgress = Math.floor((progressAll * 100 / progressMax).toFixed(2));\n    this.setState({\n      totalProgress: totalProgress\n    });\n  };\n  /**\n   * Registers listeners for all global actions, like:\n   * `file-add`, `file-remove`, `upload-progress`, `reset`\n   *\n   */\n\n\n  Uppy.prototype.actions = function actions() {\n    var _this3 = this; // this.bus.on('*', (payload) => {\n    //   console.log('emitted: ', this.event)\n    //   console.log('with payload: ', payload)\n    // })\n    // stress-test re-rendering\n    // setInterval(() => {\n    //   this.setState({bla: 'bla'})\n    // }, 20)\n\n\n    this.on('core:error', function (error) {\n      _this3.setState({\n        error: error\n      });\n    });\n    this.on('core:upload', function () {\n      _this3.setState({\n        error: null\n      });\n    });\n    this.on('core:file-add', function (data) {\n      _this3.addFile(data);\n    } // `remove-file` removes a file from `state.files`, for example when\n    // a user decides not to upload particular file and clicks a button to remove it\n    );\n    this.on('core:file-remove', function (fileID) {\n      _this3.removeFile(fileID);\n    });\n    this.on('core:cancel-all', function () {\n      // let updatedFiles = this.getState().files\n      // updatedFiles = {}\n      _this3.setState({\n        files: {}\n      });\n    });\n    this.on('core:upload-started', function (fileID, upload) {\n      var updatedFiles = _extends({}, _this3.getState().files);\n\n      var updatedFile = _extends({}, updatedFiles[fileID], _extends({}, {\n        progress: _extends({}, updatedFiles[fileID].progress, {\n          uploadStarted: Date.now()\n        })\n      }));\n\n      updatedFiles[fileID] = updatedFile;\n\n      _this3.setState({\n        files: updatedFiles\n      });\n    } // upload progress events can occur frequently, especially when you have a good\n    // connection to the remote server. Therefore, we are throtteling them to\n    // prevent accessive function calls.\n    // see also: https://github.com/tus/tus-js-client/commit/9940f27b2361fd7e10ba58b09b60d82422183bbb\n    );\n    var throttledCalculateProgress = throttle(this.calculateProgress, 100, {\n      leading: true,\n      trailing: false\n    });\n    this.on('core:upload-progress', function (data) {\n      // this.calculateProgress(data)\n      throttledCalculateProgress(data);\n    });\n    this.on('core:upload-success', function (fileID, uploadResp, uploadURL) {\n      var updatedFiles = _extends({}, _this3.getState().files);\n\n      var updatedFile = _extends({}, updatedFiles[fileID], {\n        progress: _extends({}, updatedFiles[fileID].progress, {\n          uploadComplete: true,\n          // good or bad idea? setting the percentage to 100 if upload is successful,\n          // so that if we lost some progress events on the way, its still marked “compete”?\n          percentage: 100\n        }),\n        uploadURL: uploadURL\n      });\n\n      updatedFiles[fileID] = updatedFile;\n\n      _this3.setState({\n        files: updatedFiles\n      });\n\n      _this3.calculateTotalProgress();\n\n      if (_this3.getState().totalProgress === 100) {\n        var completeFiles = Object.keys(updatedFiles).filter(function (file) {\n          return updatedFiles[file].progress.uploadComplete;\n        });\n\n        _this3.emit('core:upload-complete', completeFiles.length);\n      }\n    });\n    this.on('core:update-meta', function (data, fileID) {\n      _this3.updateMeta(data, fileID);\n    });\n    this.on('core:preprocess-progress', function (fileID, progress) {\n      var files = _extends({}, _this3.getState().files);\n\n      files[fileID] = _extends({}, files[fileID], {\n        progress: _extends({}, files[fileID].progress, {\n          preprocess: progress\n        })\n      });\n\n      _this3.setState({\n        files: files\n      });\n    });\n    this.on('core:preprocess-complete', function (fileID) {\n      var files = _extends({}, _this3.getState().files);\n\n      files[fileID] = _extends({}, files[fileID], {\n        progress: _extends({}, files[fileID].progress)\n      });\n      delete files[fileID].progress.preprocess;\n\n      _this3.setState({\n        files: files\n      });\n    });\n    this.on('core:postprocess-progress', function (fileID, progress) {\n      var files = _extends({}, _this3.getState().files);\n\n      files[fileID] = _extends({}, files[fileID], {\n        progress: _extends({}, files[fileID].progress, {\n          postprocess: progress\n        })\n      });\n\n      _this3.setState({\n        files: files\n      });\n    });\n    this.on('core:postprocess-complete', function (fileID) {\n      var files = _extends({}, _this3.getState().files);\n\n      files[fileID] = _extends({}, files[fileID], {\n        progress: _extends({}, files[fileID].progress)\n      });\n      delete files[fileID].progress.postprocess; // TODO should we set some kind of `fullyComplete` property on the file object\n      // so it's easier to see that the file is upload…fully complete…rather than\n      // what we have to do now (`uploadComplete && !postprocess`)\n\n      _this3.setState({\n        files: files\n      });\n    } // show informer if offline\n    );\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', function () {\n        return _this3.isOnline(true);\n      });\n      window.addEventListener('offline', function () {\n        return _this3.isOnline(false);\n      });\n      setTimeout(function () {\n        return _this3.isOnline();\n      }, 3000);\n    }\n  };\n\n  Uppy.prototype.isOnline = function isOnline(status) {\n    var online = status || window.navigator.onLine;\n\n    if (!online) {\n      this.emit('is-offline');\n      this.info('No internet connection', 'error', 0);\n      this.wasOffline = true;\n    } else {\n      this.emit('is-online');\n\n      if (this.wasOffline) {\n        this.emit('back-online');\n        this.info('Connected!', 'success', 3000);\n        this.wasOffline = false;\n      }\n    }\n  };\n  /**\n   * Registers a plugin with Core\n   *\n   * @param {Class} Plugin object\n   * @param {Object} options object that will be passed to Plugin later\n   * @return {Object} self for chaining\n   */\n\n\n  Uppy.prototype.use = function use(Plugin, opts) {\n    // Instantiate\n    var plugin = new Plugin(this, opts);\n    var pluginName = plugin.id;\n    this.plugins[plugin.type] = this.plugins[plugin.type] || [];\n\n    if (!pluginName) {\n      throw new Error('Your plugin must have a name');\n    }\n\n    if (!plugin.type) {\n      throw new Error('Your plugin must have a type');\n    }\n\n    var existsPluginAlready = this.getPlugin(pluginName);\n\n    if (existsPluginAlready) {\n      var msg = 'Already found a plugin named \\'' + existsPluginAlready.name + '\\'.\\n        Tried to use: \\'' + pluginName + '\\'.\\n        Uppy is currently limited to running one of every plugin.\\n        Share your use case with us over at\\n        https://github.com/transloadit/uppy/issues/\\n        if you want us to reconsider.';\n      throw new Error(msg);\n    }\n\n    this.plugins[plugin.type].push(plugin);\n    plugin.install();\n    return this;\n  };\n  /**\n   * Find one Plugin by name\n   *\n   * @param string name description\n   */\n\n\n  Uppy.prototype.getPlugin = function getPlugin(name) {\n    var foundPlugin = false;\n    this.iteratePlugins(function (plugin) {\n      var pluginName = plugin.id;\n\n      if (pluginName === name) {\n        foundPlugin = plugin;\n        return false;\n      }\n    });\n    return foundPlugin;\n  };\n  /**\n   * Iterate through all `use`d plugins\n   *\n   * @param function method description\n   */\n\n\n  Uppy.prototype.iteratePlugins = function iteratePlugins(method) {\n    var _this4 = this;\n\n    Object.keys(this.plugins).forEach(function (pluginType) {\n      _this4.plugins[pluginType].forEach(method);\n    });\n  };\n  /**\n   * Uninstall and remove a plugin.\n   *\n   * @param {Plugin} instance The plugin instance to remove.\n   */\n\n\n  Uppy.prototype.removePlugin = function removePlugin(instance) {\n    var list = this.plugins[instance.type];\n\n    if (instance.uninstall) {\n      instance.uninstall();\n    }\n\n    var index = list.indexOf(instance);\n\n    if (index !== -1) {\n      list.splice(index, 1);\n    }\n  };\n  /**\n   * Uninstall all plugins and close down this Uppy instance.\n   */\n\n\n  Uppy.prototype.close = function close() {\n    this.reset();\n    this.iteratePlugins(function (plugin) {\n      plugin.uninstall();\n    });\n\n    if (this.socket) {\n      this.socket.close();\n    }\n  };\n  /**\n  * Set info message in `state.info`, so that UI plugins like `Informer`\n  * can display the message\n  *\n  * @param {string} msg Message to be displayed by the informer\n  */\n\n\n  Uppy.prototype.info = function info(msg, type, duration) {\n    var _this5 = this;\n\n    this.setState({\n      info: {\n        isHidden: false,\n        type: type,\n        msg: msg\n      }\n    });\n    this.emit('core:info-visible');\n    window.clearTimeout(this.infoTimeoutID);\n\n    if (duration === 0) {\n      this.infoTimeoutID = undefined;\n      return;\n    } // hide the informer after `duration` milliseconds\n\n\n    this.infoTimeoutID = setTimeout(function () {\n      var newInformer = _extends({}, _this5.state.info, {\n        isHidden: true\n      });\n\n      _this5.setState({\n        info: newInformer\n      });\n\n      _this5.emit('core:info-hidden');\n    }, duration);\n  };\n\n  Uppy.prototype.hideInfo = function hideInfo() {\n    var newInfo = _extends({}, this.core.state.info, {\n      isHidden: true\n    });\n\n    this.setState({\n      info: newInfo\n    });\n    this.emit('core:info-hidden');\n  };\n  /**\n   * Logs stuff to console, only if `debug` is set to true. Silent in production.\n   *\n   * @return {String|Object} to log\n   */\n\n\n  Uppy.prototype.log = function log(msg, type) {\n    if (!this.opts.debug) {\n      return;\n    }\n\n    if (type === 'error') {\n      console.error('LOG: ' + msg);\n      return;\n    }\n\n    if (msg === '' + msg) {\n      console.log('LOG: ' + msg);\n    } else {\n      console.dir(msg);\n    }\n\n    global.uppyLog = global.uppyLog + '\\n' + 'DEBUG LOG: ' + msg;\n  };\n\n  Uppy.prototype.initSocket = function initSocket(opts) {\n    if (!this.socket) {\n      this.socket = new UppySocket(opts);\n    }\n\n    return this.socket;\n  };\n  /**\n   * Initializes actions, installs all plugins (by iterating on them and calling `install`), sets options\n   *\n   */\n\n\n  Uppy.prototype.run = function run() {\n    this.log('Core is run, initializing actions...');\n    this.actions // Forse set `autoProceed` option to false if there are multiple selector Plugins active\n    // if (this.plugins.acquirer && this.plugins.acquirer.length > 1) {\n    //   this.opts.autoProceed = false\n    // }\n    // Install all plugins\n    // this.installAll()\n    ();\n    return this;\n  };\n  /**\n   * Restore an upload by its ID.\n   */\n\n\n  Uppy.prototype.restore = function restore(uploadID) {\n    this.log('Core: attempting to restore upload \"' + uploadID + '\"');\n\n    if (!this.state.currentUploads[uploadID]) {\n      this.removeUpload(uploadID);\n      return Promise.reject(new Error('Nonexistent upload'));\n    }\n\n    return this.runUpload(uploadID);\n  };\n  /**\n   * Create an upload for a bunch of files.\n   *\n   * @param {Array<string>} fileIDs File IDs to include in this upload.\n   * @return {string} ID of this upload.\n   */\n\n\n  Uppy.prototype.createUpload = function createUpload(fileIDs) {\n    var _extends2;\n\n    var uploadID = cuid();\n    this.emit('core:upload', {\n      id: uploadID,\n      fileIDs: fileIDs\n    });\n    this.setState({\n      currentUploads: _extends({}, this.state.currentUploads, (_extends2 = {}, _extends2[uploadID] = {\n        fileIDs: fileIDs,\n        step: 0\n      }, _extends2))\n    });\n    return uploadID;\n  };\n  /**\n   * Remove an upload, eg. if it has been canceled or completed.\n   *\n   * @param {string} uploadID The ID of the upload.\n   */\n\n\n  Uppy.prototype.removeUpload = function removeUpload(uploadID) {\n    var currentUploads = _extends({}, this.state.currentUploads);\n\n    delete currentUploads[uploadID];\n    this.setState({\n      currentUploads: currentUploads\n    });\n  };\n  /**\n   * Run an upload. This picks up where it left off in case the upload is being restored.\n   *\n   * @private\n   */\n\n\n  Uppy.prototype.runUpload = function runUpload(uploadID) {\n    var _this6 = this;\n\n    var uploadData = this.state.currentUploads[uploadID];\n    var fileIDs = uploadData.fileIDs;\n    var restoreStep = uploadData.step;\n    var steps = [].concat(this.preProcessors, this.uploaders, this.postProcessors);\n    var lastStep = Promise.resolve();\n    steps.forEach(function (fn, step) {\n      // Skip this step if we are restoring and have already completed this step before.\n      if (step < restoreStep) {\n        return;\n      }\n\n      lastStep = lastStep.then(function () {\n        var _extends3;\n\n        var currentUpload = _extends({}, _this6.state.currentUploads[uploadID], {\n          step: step\n        });\n\n        _this6.setState({\n          currentUploads: _extends({}, _this6.state.currentUploads, (_extends3 = {}, _extends3[uploadID] = currentUpload, _extends3))\n        });\n\n        return fn(fileIDs);\n      });\n    } // Not returning the `catch`ed promise, because we still want to return a rejected\n    // promise from this method if the upload failed.\n    );\n    lastStep.catch(function (err) {\n      _this6.emit('core:error', err);\n\n      _this6.removeUpload(uploadID);\n    });\n    return lastStep.then(function () {\n      // return number of uploaded files\n      _this6.emit('core:success', fileIDs);\n\n      _this6.removeUpload(uploadID);\n    });\n  };\n  /**\n  * Start an upload for all the files that are not currently being uploaded.\n  *\n  * @return {Promise}\n  */\n\n\n  Uppy.prototype.upload = function upload(forceUpload) {\n    var _this7 = this;\n\n    var isMinNumberOfFilesReached = this.checkRestrictions(true);\n\n    if (!isMinNumberOfFilesReached) {\n      return Promise.reject('Minimum number of files has not been reached');\n    }\n\n    return this.opts.onBeforeUpload(this.state.files).catch(function (err) {\n      _this7.info(err, 'error', 5000);\n\n      return Promise.reject('onBeforeUpload: ' + err);\n    }).then(function () {\n      var waitingFileIDs = [];\n      Object.keys(_this7.state.files).forEach(function (fileID) {\n        var file = _this7.getFile(fileID // TODO: replace files[file].isRemote with some logic\n        //\n        // filter files that are now yet being uploaded / haven’t been uploaded\n        // and remote too\n        );\n\n        if (forceUpload) {\n          _this7.resetProgress();\n\n          waitingFileIDs.push(file.id);\n        } else if (!file.progress.uploadStarted || file.isRemote) {\n          waitingFileIDs.push(file.id);\n        }\n      });\n\n      var uploadID = _this7.createUpload(waitingFileIDs);\n\n      return _this7.runUpload(uploadID);\n    });\n  };\n\n  return Uppy;\n}();\n\nmodule.exports = function (opts) {\n  if (!(this instanceof Uppy)) {\n    return new Uppy(opts);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}