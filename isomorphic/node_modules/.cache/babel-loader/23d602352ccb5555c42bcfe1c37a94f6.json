{"ast":null,"code":"/**\n* Create an event emitter with namespaces\n* @name createNamespaceEmitter\n* @example\n* var emitter = require('./index')()\n*\n* emitter.on('*', function () {\n*   console.log('all events emitted', this.event)\n* })\n*\n* emitter.on('example', function () {\n*   console.log('example event emitted')\n* })\n*/\nmodule.exports = function createNamespaceEmitter() {\n  var emitter = {\n    _fns: {}\n    /**\n    * Emit an event. Optionally namespace the event. Separate the namespace and event with a `:`\n    * @name emit\n    * @param {String} event – the name of the event, with optional namespace\n    * @param {...*} data – data variables that will be passed as arguments to the event listener\n    * @example\n    * emitter.emit('example')\n    * emitter.emit('demo:test')\n    * emitter.emit('data', { example: true}, 'a string', 1)\n    */\n\n  };\n\n  emitter.emit = function emit(event) {\n    var args = [].slice.call(arguments, 1);\n    var namespaced = namespaces(event);\n    if (this._fns[event]) emitAll(event, this._fns[event], args);\n    if (namespaced) emitAll(event, namespaced, args);\n  };\n  /**\n  * Create en event listener.\n  * @name on\n  * @param {String} event\n  * @param {Function} fn\n  * @example\n  * emitter.on('example', function () {})\n  * emitter.on('demo', function () {})\n  */\n\n\n  emitter.on = function on(event, fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('callback required');\n    }\n\n    (this._fns[event] = this._fns[event] || []).push(fn);\n  };\n  /**\n  * Create en event listener that fires once.\n  * @name once\n  * @param {String} event\n  * @param {Function} fn\n  * @example\n  * emitter.once('example', function () {})\n  * emitter.once('demo', function () {})\n  */\n\n\n  emitter.once = function once(event, fn) {\n    function one() {\n      fn.apply(this, arguments);\n      emitter.off(event, one);\n    }\n\n    this.on(event, one);\n  };\n  /**\n  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.\n  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener, \n  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener\n  * @name off\n  * @param {String} event\n  * @param {Function} [fn] – the specific handler\n  * @example\n  * emitter.off('example')\n  * emitter.off('demo', function () {})\n  */\n\n\n  emitter.off = function off(event, fn) {\n    var keep = [];\n\n    if (event && fn) {\n      for (var i = 0; i < this._fns.length; i++) {\n        if (this._fns[i] !== fn) {\n          keep.push(this._fns[i]);\n        }\n      }\n    }\n\n    keep.length ? this._fns[event] = keep : delete this._fns[event];\n  };\n\n  function namespaces(e) {\n    var out = [];\n    var args = e.split(':');\n    var fns = emitter._fns;\n    Object.keys(fns).forEach(function (key) {\n      if (key === '*') out = out.concat(fns[key]);\n      if (args.length === 2 && args[0] === key) out = out.concat(fns[key]);\n    });\n    return out;\n  }\n\n  function emitAll(e, fns, args) {\n    for (var i = 0; i < fns.length; i++) {\n      if (!fns[i]) break;\n      fns[i].event = e;\n      fns[i].apply(fns[i], args);\n    }\n  }\n\n  return emitter;\n};","map":null,"metadata":{},"sourceType":"script"}