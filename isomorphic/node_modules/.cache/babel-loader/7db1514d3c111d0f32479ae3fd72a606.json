{"ast":null,"code":"var document = require('global/document');\n\nvar hyperx = require('hyperx');\n\nvar onload = require('on-load');\n\nvar SVGNS = 'http://www.w3.org/2000/svg';\nvar XLINKNS = 'http://www.w3.org/1999/xlink';\nvar BOOL_PROPS = {\n  autofocus: 1,\n  checked: 1,\n  defaultchecked: 1,\n  disabled: 1,\n  formnovalidate: 1,\n  indeterminate: 1,\n  readonly: 1,\n  required: 1,\n  selected: 1,\n  willvalidate: 1\n};\nvar COMMENT_TAG = '!--';\nvar SVG_TAGS = ['svg', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'];\n\nfunction belCreateElement(tag, props, children) {\n  var el; // If an svg tag, it needs a namespace\n\n  if (SVG_TAGS.indexOf(tag) !== -1) {\n    props.namespace = SVGNS;\n  } // If we are using a namespace\n\n\n  var ns = false;\n\n  if (props.namespace) {\n    ns = props.namespace;\n    delete props.namespace;\n  } // Create the element\n\n\n  if (ns) {\n    el = document.createElementNS(ns, tag);\n  } else if (tag === COMMENT_TAG) {\n    return document.createComment(props.comment);\n  } else {\n    el = document.createElement(tag);\n  } // If adding onload events\n\n\n  if (props.onload || props.onunload) {\n    var load = props.onload || function () {};\n\n    var unload = props.onunload || function () {};\n\n    onload(el, function belOnload() {\n      load(el);\n    }, function belOnunload() {\n      unload(el);\n    }, // We have to use non-standard `caller` to find who invokes `belCreateElement`\n    belCreateElement.caller.caller.caller);\n    delete props.onload;\n    delete props.onunload;\n  } // Create the properties\n\n\n  for (var p in props) {\n    if (props.hasOwnProperty(p)) {\n      var key = p.toLowerCase();\n      var val = props[p]; // Normalize className\n\n      if (key === 'classname') {\n        key = 'class';\n        p = 'class';\n      } // The for attribute gets transformed to htmlFor, but we just set as for\n\n\n      if (p === 'htmlFor') {\n        p = 'for';\n      } // If a property is boolean, set itself to the key\n\n\n      if (BOOL_PROPS[key]) {\n        if (val === 'true') val = key;else if (val === 'false') continue;\n      } // If a property prefers being set directly vs setAttribute\n\n\n      if (key.slice(0, 2) === 'on') {\n        el[p] = val;\n      } else {\n        if (ns) {\n          if (p === 'xlink:href') {\n            el.setAttributeNS(XLINKNS, p, val);\n          } else if (/^xmlns($|:)/i.test(p)) {// skip xmlns definitions\n          } else {\n            el.setAttributeNS(null, p, val);\n          }\n        } else {\n          el.setAttribute(p, val);\n        }\n      }\n    }\n  }\n\n  function appendChild(childs) {\n    if (!Array.isArray(childs)) return;\n\n    for (var i = 0; i < childs.length; i++) {\n      var node = childs[i];\n\n      if (Array.isArray(node)) {\n        appendChild(node);\n        continue;\n      }\n\n      if (typeof node === 'number' || typeof node === 'boolean' || typeof node === 'function' || node instanceof Date || node instanceof RegExp) {\n        node = node.toString();\n      }\n\n      if (typeof node === 'string') {\n        if (el.lastChild && el.lastChild.nodeName === '#text') {\n          el.lastChild.nodeValue += node;\n          continue;\n        }\n\n        node = document.createTextNode(node);\n      }\n\n      if (node && node.nodeType) {\n        el.appendChild(node);\n      }\n    }\n  }\n\n  appendChild(children);\n  return el;\n}\n\nmodule.exports = hyperx(belCreateElement, {\n  comments: true\n});\nmodule.exports.default = module.exports;\nmodule.exports.createElement = belCreateElement;","map":null,"metadata":{},"sourceType":"script"}