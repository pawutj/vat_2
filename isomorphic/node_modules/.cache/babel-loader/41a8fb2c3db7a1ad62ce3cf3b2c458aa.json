{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;\n\nvar throttle = require('lodash.throttle' // we inline file-type module, as opposed to using the NPM version,\n// because of this https://github.com/sindresorhus/file-type/issues/78\n// and https://github.com/sindresorhus/copy-text-to-clipboard/issues/5\n);\n\nvar fileType = require('../vendor/file-type'\n/**\n * A collection of small utility functions that help with dom manipulation, adding listeners,\n * promises and other good things.\n *\n * @module Utils\n */\n\n/**\n * Shallow flatten nested arrays.\n */\n);\n\nfunction flatten(arr) {\n  return [].concat.apply([], arr);\n}\n\nfunction isTouchDevice() {\n  return 'ontouchstart' in window || // works on most browsers\n  navigator.maxTouchPoints; // works on IE10/11 and Surface\n} // /**\n//  * Shorter and fast way to select a single node in the DOM\n//  * @param   { String } selector - unique dom selector\n//  * @param   { Object } ctx - DOM node where the target of our search will is located\n//  * @returns { Object } dom node found\n//  */\n// function $ (selector, ctx) {\n//   return (ctx || document).querySelector(selector)\n// }\n// /**\n//  * Shorter and fast way to select multiple nodes in the DOM\n//  * @param   { String|Array } selector - DOM selector or nodes list\n//  * @param   { Object } ctx - DOM node where the targets of our search will is located\n//  * @returns { Object } dom nodes found\n//  */\n// function $$ (selector, ctx) {\n//   var els\n//   if (typeof selector === 'string') {\n//     els = (ctx || document).querySelectorAll(selector)\n//   } else {\n//     els = selector\n//     return Array.prototype.slice.call(els)\n//   }\n// }\n\n\nfunction truncateString(str, length) {\n  if (str.length > length) {\n    return str.substr(0, length / 2) + '...' + str.substr(str.length - length / 4, str.length);\n  }\n\n  return str; // more precise version if needed\n  // http://stackoverflow.com/a/831583\n}\n\nfunction secondsToTime(rawSeconds) {\n  var hours = Math.floor(rawSeconds / 3600) % 24;\n  var minutes = Math.floor(rawSeconds / 60) % 60;\n  var seconds = Math.floor(rawSeconds % 60);\n  return {\n    hours: hours,\n    minutes: minutes,\n    seconds: seconds\n  };\n}\n/**\n * Partition array by a grouping function.\n * @param  {[type]} array      Input array\n * @param  {[type]} groupingFn Grouping function\n * @return {[type]}            Array of arrays\n */\n\n\nfunction groupBy(array, groupingFn) {\n  return array.reduce(function (result, item) {\n    var key = groupingFn(item);\n    var xs = result.get(key) || [];\n    xs.push(item);\n    result.set(key, xs);\n    return result;\n  }, new Map());\n}\n/**\n * Tests if every array element passes predicate\n * @param  {Array}  array       Input array\n * @param  {Object} predicateFn Predicate\n * @return {bool}               Every element pass\n */\n\n\nfunction every(array, predicateFn) {\n  return array.reduce(function (result, item) {\n    if (!result) {\n      return false;\n    }\n\n    return predicateFn(item);\n  }, true);\n}\n/**\n * Converts list into array\n*/\n\n\nfunction toArray(list) {\n  return Array.prototype.slice.call(list || [], 0);\n}\n/**\n * Takes a fileName and turns it into fileID, by converting to lowercase,\n * removing extra characters and adding unix timestamp\n *\n * @param {String} fileName\n *\n */\n\n\nfunction generateFileID(file) {\n  console.log(file);\n  var fileID = file.name.toLowerCase();\n  fileID = fileID.replace(/[^A-Z0-9]/ig, '');\n  fileID = fileID + file.data.lastModified;\n  return fileID;\n}\n\nfunction extend() {\n  for (var _len = arguments.length, objs = Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n\n  return Object.assign.apply(this, [{}].concat(objs));\n}\n/**\n * Runs an array of promise-returning functions in sequence.\n */\n\n\nfunction runPromiseSequence(functions) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  var promise = Promise.resolve();\n  functions.forEach(function (func) {\n    promise = promise.then(function () {\n      return func.apply(undefined, args);\n    });\n  });\n  return promise;\n}\n/**\n * Takes function or class, returns its name.\n * Because IE doesn’t support `constructor.name`.\n * https://gist.github.com/dfkaye/6384439, http://stackoverflow.com/a/15714445\n *\n * @param {Object} fn — function\n *\n */\n// function getFnName (fn) {\n//   var f = typeof fn === 'function'\n//   var s = f && ((fn.name && ['', fn.name]) || fn.toString().match(/function ([^\\(]+)/))\n//   return (!f && 'not a function') || (s && s[1] || 'anonymous')\n// }\n\n\nfunction isPreviewSupported(fileTypeSpecific) {\n  // list of images that browsers can preview\n  if (/^(jpeg|gif|png|svg|svg\\+xml|bmp)$/.test(fileTypeSpecific)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getArrayBuffer(chunk) {\n  return new _Promise(function (resolve, reject) {\n    var reader = new FileReader();\n    reader.addEventListener('load', function (e) {\n      // e.target.result is an ArrayBuffer\n      resolve(e.target.result);\n    });\n    reader.addEventListener('error', function (err) {\n      console.error('FileReader error' + err);\n      reject(err);\n    } // file-type only needs the first 4100 bytes\n    );\n    reader.readAsArrayBuffer(chunk);\n  });\n}\n\nfunction getFileType(file) {\n  var emptyFileType = ['', ''];\n  var extensionsToMime = {\n    'md': 'text/markdown',\n    'markdown': 'text/markdown',\n    'mp4': 'video/mp4',\n    'mp3': 'audio/mp3' // no smart detection for remote files, just trust the provider\n\n  };\n\n  if (file.isRemote) {\n    return Promise.resolve(file.type.split('/'));\n  }\n\n  var fileExtension = getFileNameAndExtension(file.name)[1]; // 1. try to determine file type from magic bytes with file-type module\n  // this should be the most trustworthy way\n\n  var chunk = file.data.slice(0, 4100);\n  return getArrayBuffer(chunk).then(function (buffer) {\n    var type = fileType(buffer);\n\n    if (type && type.mime) {\n      return type.mime.split('/');\n    } // 2. if that’s no good, check if mime type is set in the file object\n\n\n    if (file.type) {\n      return file.type.split('/');\n    } // 3. if that’s no good, see if we can map extension to a mime type\n\n\n    if (extensionsToMime[fileExtension]) {\n      return extensionsToMime[fileExtension].split('/');\n    } // if all fails, well, return empty\n\n\n    return emptyFileType;\n  }).catch(function () {\n    return emptyFileType;\n  } // if (file.type) {\n  //   return Promise.resolve(file.type.split('/'))\n  // }\n  // return mime.lookup(file.name)\n  // return file.type ? file.type.split('/') : ['', '']\n  );\n} // TODO Check which types are actually supported in browsers. Chrome likes webm\n// from my testing, but we may need more.\n// We could use a library but they tend to contain dozens of KBs of mappings,\n// most of which will go unused, so not sure if that's worth it.\n\n\nvar mimeToExtensions = {\n  'video/ogg': 'ogv',\n  'audio/ogg': 'ogg',\n  'video/webm': 'webm',\n  'audio/webm': 'webm',\n  'video/mp4': 'mp4',\n  'audio/mp3': 'mp3'\n};\n\nfunction getFileTypeExtension(mimeType) {\n  return mimeToExtensions[mimeType] || null;\n} // returns [fileName, fileExt]\n\n\nfunction getFileNameAndExtension(fullFileName) {\n  var re = /(?:\\.([^.]+))?$/;\n  var fileExt = re.exec(fullFileName)[1];\n  var fileName = fullFileName.replace('.' + fileExt, '');\n  return [fileName, fileExt];\n}\n\nfunction getThumbnail(fileData) {\n  return URL.createObjectURL(fileData);\n}\n\nfunction supportsMediaRecorder() {\n  return typeof MediaRecorder === 'function' && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start === 'function';\n}\n\nfunction dataURItoBlob(dataURI, opts, toFile) {\n  // get the base64 data\n  var data = dataURI.split(',')[1]; // user may provide mime type, if not get it from data URI\n\n  var mimeType = opts.mimeType || dataURI.split(',')[0].split(':')[1].split(';')[0]; // default to plain/text if data URI has no mimeType\n\n  if (mimeType == null) {\n    mimeType = 'plain/text';\n  }\n\n  var binary = atob(data);\n  var array = [];\n\n  for (var i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  } // Convert to a File?\n\n\n  if (toFile) {\n    return new File([new Uint8Array(array)], opts.name || '', {\n      type: mimeType\n    });\n  }\n\n  return new Blob([new Uint8Array(array)], {\n    type: mimeType\n  });\n}\n\nfunction dataURItoFile(dataURI, opts) {\n  return dataURItoBlob(dataURI, opts, true);\n}\n/**\n * Copies text to clipboard by creating an almost invisible textarea,\n * adding text there, then running execCommand('copy').\n * Falls back to prompt() when the easy way fails (hello, Safari!)\n * From http://stackoverflow.com/a/30810322\n *\n * @param {String} textToCopy\n * @param {String} fallbackString\n * @return {Promise}\n */\n\n\nfunction copyToClipboard(textToCopy, fallbackString) {\n  fallbackString = fallbackString || 'Copy the URL below';\n  return new _Promise(function (resolve, reject) {\n    var textArea = document.createElement('textarea');\n    textArea.setAttribute('style', {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '2em',\n      height: '2em',\n      padding: 0,\n      border: 'none',\n      outline: 'none',\n      boxShadow: 'none',\n      background: 'transparent'\n    });\n    textArea.value = textToCopy;\n    document.body.appendChild(textArea);\n    textArea.select();\n\n    var magicCopyFailed = function magicCopyFailed(err) {\n      document.body.removeChild(textArea);\n      window.prompt(fallbackString, textToCopy);\n      return reject('Oops, unable to copy displayed fallback prompt: ' + err);\n    };\n\n    try {\n      var successful = document.execCommand('copy');\n\n      if (!successful) {\n        return magicCopyFailed('copy command unavailable');\n      }\n\n      document.body.removeChild(textArea);\n      return resolve();\n    } catch (err) {\n      document.body.removeChild(textArea);\n      return magicCopyFailed(err);\n    }\n  });\n}\n\nfunction getSpeed(fileProgress) {\n  if (!fileProgress.bytesUploaded) return 0;\n  var timeElapsed = new Date() - fileProgress.uploadStarted;\n  var uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1000);\n  return uploadSpeed;\n}\n\nfunction getBytesRemaining(fileProgress) {\n  return fileProgress.bytesTotal - fileProgress.bytesUploaded;\n}\n\nfunction getETA(fileProgress) {\n  if (!fileProgress.bytesUploaded) return 0;\n  var uploadSpeed = getSpeed(fileProgress);\n  var bytesRemaining = getBytesRemaining(fileProgress);\n  var secondsRemaining = Math.round(bytesRemaining / uploadSpeed * 10) / 10;\n  return secondsRemaining;\n}\n\nfunction prettyETA(seconds) {\n  var time = secondsToTime(seconds // Only display hours and minutes if they are greater than 0 but always\n  // display minutes if hours is being displayed\n  // Display a leading zero if the there is a preceding unit: 1m 05s, but 5s\n  );\n  var hoursStr = time.hours ? time.hours + 'h ' : '';\n  var minutesVal = time.hours ? ('0' + time.minutes).substr(-2) : time.minutes;\n  var minutesStr = minutesVal ? minutesVal + 'm ' : '';\n  var secondsVal = minutesVal ? ('0' + time.seconds).substr(-2) : time.seconds;\n  var secondsStr = secondsVal + 's';\n  return '' + hoursStr + minutesStr + secondsStr;\n}\n/**\n * Check if an object is a DOM element. Duck-typing based on `nodeType`.\n *\n * @param {*} obj\n */\n\n\nfunction isDOMElement(obj) {\n  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Find a DOM element.\n *\n * @param {Node|string} element\n * @return {Node|null}\n */\n\n\nfunction findDOMElement(element) {\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if ((typeof element === 'undefined' ? 'undefined' : _typeof(element)) === 'object' && isDOMElement(element)) {\n    return element;\n  }\n}\n\nfunction getSocketHost(url) {\n  // get the host domain\n  var regex = /^(?:https?:\\/\\/|\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^\\n]+)/;\n  var host = regex.exec(url)[1];\n  var socketProtocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  return socketProtocol + '://' + host;\n}\n\nfunction _emitSocketProgress(uploader, progressData, file) {\n  var progress = progressData.progress,\n      bytesUploaded = progressData.bytesUploaded,\n      bytesTotal = progressData.bytesTotal;\n\n  if (progress) {\n    uploader.core.log('Upload progress: ' + progress);\n    uploader.core.emitter.emit('core:upload-progress', {\n      uploader: uploader,\n      id: file.id,\n      bytesUploaded: bytesUploaded,\n      bytesTotal: bytesTotal\n    });\n  }\n}\n\nvar emitSocketProgress = throttle(_emitSocketProgress, 300, {\n  leading: true,\n  trailing: true\n});\nmodule.exports = {\n  generateFileID: generateFileID,\n  toArray: toArray,\n  every: every,\n  flatten: flatten,\n  groupBy: groupBy,\n  extend: extend,\n  runPromiseSequence: runPromiseSequence,\n  supportsMediaRecorder: supportsMediaRecorder,\n  isTouchDevice: isTouchDevice,\n  getFileNameAndExtension: getFileNameAndExtension,\n  truncateString: truncateString,\n  getFileTypeExtension: getFileTypeExtension,\n  getFileType: getFileType,\n  getArrayBuffer: getArrayBuffer,\n  isPreviewSupported: isPreviewSupported,\n  getThumbnail: getThumbnail,\n  secondsToTime: secondsToTime,\n  dataURItoBlob: dataURItoBlob,\n  dataURItoFile: dataURItoFile,\n  getSpeed: getSpeed,\n  getBytesRemaining: getBytesRemaining,\n  getETA: getETA,\n  copyToClipboard: copyToClipboard,\n  prettyETA: prettyETA,\n  findDOMElement: findDOMElement,\n  getSocketHost: getSocketHost,\n  emitSocketProgress: emitSocketProgress\n};","map":null,"metadata":{},"sourceType":"script"}