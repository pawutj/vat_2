{"ast":null,"code":"var attrToProp = require('hyperscript-attribute-to-property');\n\nvar VAR = 0,\n    TEXT = 1,\n    OPEN = 2,\n    CLOSE = 3,\n    ATTR = 4;\nvar ATTR_KEY = 5,\n    ATTR_KEY_W = 6;\nvar ATTR_VALUE_W = 7,\n    ATTR_VALUE = 8;\nvar ATTR_VALUE_SQ = 9,\n    ATTR_VALUE_DQ = 10;\nvar ATTR_EQ = 11,\n    ATTR_BREAK = 12;\nvar COMMENT = 13;\n\nmodule.exports = function (h, opts) {\n  if (!opts) opts = {};\n\n  var concat = opts.concat || function (a, b) {\n    return String(a) + String(b);\n  };\n\n  if (opts.attrToProp !== false) {\n    h = attrToProp(h);\n  }\n\n  return function (strings) {\n    var state = TEXT,\n        reg = '';\n    var arglen = arguments.length;\n    var parts = [];\n\n    for (var i = 0; i < strings.length; i++) {\n      if (i < arglen - 1) {\n        var arg = arguments[i + 1];\n        var p = parse(strings[i]);\n        var xstate = state;\n        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE;\n        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE;\n        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE;\n        if (xstate === ATTR) xstate = ATTR_KEY;\n\n        if (xstate === OPEN) {\n          if (reg === '/') {\n            p.push([OPEN, '/', arg]);\n            reg = '';\n          } else {\n            p.push([OPEN, arg]);\n          }\n        } else if (xstate === COMMENT && opts.comments) {\n          reg += String(arg);\n        } else if (xstate !== COMMENT) {\n          p.push([VAR, xstate, arg]);\n        }\n\n        parts.push.apply(parts, p);\n      } else parts.push.apply(parts, parse(strings[i]));\n    }\n\n    var tree = [null, {}, []];\n    var stack = [[tree, -1]];\n\n    for (var i = 0; i < parts.length; i++) {\n      var cur = stack[stack.length - 1][0];\n      var p = parts[i],\n          s = p[0];\n\n      if (s === OPEN && /^\\//.test(p[1])) {\n        var ix = stack[stack.length - 1][1];\n\n        if (stack.length > 1) {\n          stack.pop();\n          stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : undefined);\n        }\n      } else if (s === OPEN) {\n        var c = [p[1], {}, []];\n        cur[2].push(c);\n        stack.push([c, cur[2].length - 1]);\n      } else if (s === ATTR_KEY || s === VAR && p[1] === ATTR_KEY) {\n        var key = '';\n        var copyKey;\n\n        for (; i < parts.length; i++) {\n          if (parts[i][0] === ATTR_KEY) {\n            key = concat(key, parts[i][1]);\n          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {\n            if (typeof parts[i][2] === 'object' && !key) {\n              for (copyKey in parts[i][2]) {\n                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {\n                  cur[1][copyKey] = parts[i][2][copyKey];\n                }\n              }\n            } else {\n              key = concat(key, parts[i][2]);\n            }\n          } else break;\n        }\n\n        if (parts[i][0] === ATTR_EQ) i++;\n        var j = i;\n\n        for (; i < parts.length; i++) {\n          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {\n            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1]);else parts[i][1] === \"\" || (cur[1][key] = concat(cur[1][key], parts[i][1]));\n          } else if (parts[i][0] === VAR && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {\n            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2]);else parts[i][2] === \"\" || (cur[1][key] = concat(cur[1][key], parts[i][2]));\n          } else {\n            if (key.length && !cur[1][key] && i === j && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {\n              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes\n              // empty string is falsy, not well behaved value in browser\n              cur[1][key] = key.toLowerCase();\n            }\n\n            if (parts[i][0] === CLOSE) {\n              i--;\n            }\n\n            break;\n          }\n        }\n      } else if (s === ATTR_KEY) {\n        cur[1][p[1]] = true;\n      } else if (s === VAR && p[1] === ATTR_KEY) {\n        cur[1][p[2]] = true;\n      } else if (s === CLOSE) {\n        if (selfClosing(cur[0]) && stack.length) {\n          var ix = stack[stack.length - 1][1];\n          stack.pop();\n          stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : undefined);\n        }\n      } else if (s === VAR && p[1] === TEXT) {\n        if (p[2] === undefined || p[2] === null) p[2] = '';else if (!p[2]) p[2] = concat('', p[2]);\n\n        if (Array.isArray(p[2][0])) {\n          cur[2].push.apply(cur[2], p[2]);\n        } else {\n          cur[2].push(p[2]);\n        }\n      } else if (s === TEXT) {\n        cur[2].push(p[1]);\n      } else if (s === ATTR_EQ || s === ATTR_BREAK) {// no-op\n      } else {\n        throw new Error('unhandled: ' + s);\n      }\n    }\n\n    if (tree[2].length > 1 && /^\\s*$/.test(tree[2][0])) {\n      tree[2].shift();\n    }\n\n    if (tree[2].length > 2 || tree[2].length === 2 && /\\S/.test(tree[2][1])) {\n      if (opts.createFragment) return opts.createFragment(tree[2]);\n      throw new Error('multiple root elements must be wrapped in an enclosing tag');\n    }\n\n    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string' && Array.isArray(tree[2][0][2])) {\n      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2]);\n    }\n\n    return tree[2][0];\n\n    function parse(str) {\n      var res = [];\n      if (state === ATTR_VALUE_W) state = ATTR;\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n\n        if (state === TEXT && c === '<') {\n          if (reg.length) res.push([TEXT, reg]);\n          reg = '';\n          state = OPEN;\n        } else if (c === '>' && !quot(state) && state !== COMMENT) {\n          if (state === OPEN && reg.length) {\n            res.push([OPEN, reg]);\n          } else if (state === ATTR_KEY) {\n            res.push([ATTR_KEY, reg]);\n          } else if (state === ATTR_VALUE && reg.length) {\n            res.push([ATTR_VALUE, reg]);\n          }\n\n          res.push([CLOSE]);\n          reg = '';\n          state = TEXT;\n        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {\n          if (opts.comments) {\n            res.push([ATTR_VALUE, reg.substr(0, reg.length - 1)]);\n          }\n\n          reg = '';\n          state = TEXT;\n        } else if (state === OPEN && /^!--$/.test(reg)) {\n          if (opts.comments) {\n            res.push([OPEN, reg], [ATTR_KEY, 'comment'], [ATTR_EQ]);\n          }\n\n          reg = c;\n          state = COMMENT;\n        } else if (state === TEXT || state === COMMENT) {\n          reg += c;\n        } else if (state === OPEN && c === '/' && reg.length) {// no-op, self closing tag without a space <br/>\n        } else if (state === OPEN && /\\s/.test(c)) {\n          if (reg.length) {\n            res.push([OPEN, reg]);\n          }\n\n          reg = '';\n          state = ATTR;\n        } else if (state === OPEN) {\n          reg += c;\n        } else if (state === ATTR && /[^\\s\"'=/]/.test(c)) {\n          state = ATTR_KEY;\n          reg = c;\n        } else if (state === ATTR && /\\s/.test(c)) {\n          if (reg.length) res.push([ATTR_KEY, reg]);\n          res.push([ATTR_BREAK]);\n        } else if (state === ATTR_KEY && /\\s/.test(c)) {\n          res.push([ATTR_KEY, reg]);\n          reg = '';\n          state = ATTR_KEY_W;\n        } else if (state === ATTR_KEY && c === '=') {\n          res.push([ATTR_KEY, reg], [ATTR_EQ]);\n          reg = '';\n          state = ATTR_VALUE_W;\n        } else if (state === ATTR_KEY) {\n          reg += c;\n        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {\n          res.push([ATTR_EQ]);\n          state = ATTR_VALUE_W;\n        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\\s/.test(c)) {\n          res.push([ATTR_BREAK]);\n\n          if (/[\\w-]/.test(c)) {\n            reg += c;\n            state = ATTR_KEY;\n          } else state = ATTR;\n        } else if (state === ATTR_VALUE_W && c === '\"') {\n          state = ATTR_VALUE_DQ;\n        } else if (state === ATTR_VALUE_W && c === \"'\") {\n          state = ATTR_VALUE_SQ;\n        } else if (state === ATTR_VALUE_DQ && c === '\"') {\n          res.push([ATTR_VALUE, reg], [ATTR_BREAK]);\n          reg = '';\n          state = ATTR;\n        } else if (state === ATTR_VALUE_SQ && c === \"'\") {\n          res.push([ATTR_VALUE, reg], [ATTR_BREAK]);\n          reg = '';\n          state = ATTR;\n        } else if (state === ATTR_VALUE_W && !/\\s/.test(c)) {\n          state = ATTR_VALUE;\n          i--;\n        } else if (state === ATTR_VALUE && /\\s/.test(c)) {\n          res.push([ATTR_VALUE, reg], [ATTR_BREAK]);\n          reg = '';\n          state = ATTR;\n        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ) {\n          reg += c;\n        }\n      }\n\n      if (state === TEXT && reg.length) {\n        res.push([TEXT, reg]);\n        reg = '';\n      } else if (state === ATTR_VALUE && reg.length) {\n        res.push([ATTR_VALUE, reg]);\n        reg = '';\n      } else if (state === ATTR_VALUE_DQ && reg.length) {\n        res.push([ATTR_VALUE, reg]);\n        reg = '';\n      } else if (state === ATTR_VALUE_SQ && reg.length) {\n        res.push([ATTR_VALUE, reg]);\n        reg = '';\n      } else if (state === ATTR_KEY) {\n        res.push([ATTR_KEY, reg]);\n        reg = '';\n      }\n\n      return res;\n    }\n  };\n\n  function strfn(x) {\n    if (typeof x === 'function') return x;else if (typeof x === 'string') return x;else if (x && typeof x === 'object') return x;else if (x === null || x === undefined) return x;else return concat('', x);\n  }\n};\n\nfunction quot(state) {\n  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ;\n}\n\nvar closeRE = RegExp('^(' + ['area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed', 'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr', '!--', // SVG TAGS\n'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse', 'feBlend', 'feColorMatrix', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath', 'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view', 'vkern'].join('|') + \")(?:[.#][a-zA-Z0-9\\x7F-\\uFFFF_:-]+)*$\");\n\nfunction selfClosing(tag) {\n  return closeRE.test(tag);\n}","map":null,"metadata":{},"sourceType":"script"}