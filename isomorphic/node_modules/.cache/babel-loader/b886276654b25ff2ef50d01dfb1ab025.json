{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3.js\n// @output_wrapper (function() {%output%})();\n// ==/ClosureCompiler==\n\n/**\n * @license\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A RichMarker that allows any HTML/DOM to be added to a map and be draggable.\n *\n * @param {Object.<string, *>=} opt_options Optional properties to set.\n * @extends {google.maps.OverlayView}\n * @constructor\n */\n\n\nvar RichMarker = exports.RichMarker = function (_google$maps$OverlayV) {\n  _inherits(RichMarker, _google$maps$OverlayV);\n\n  function RichMarker(opt_options) {\n    _classCallCheck(this, RichMarker);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RichMarker).call(this));\n\n    var options = opt_options || {};\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.ready_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.dragging_ = false;\n\n    if (opt_options['visible'] == undefined) {\n      opt_options['visible'] = true;\n    }\n\n    if (opt_options['shadow'] == undefined) {\n      opt_options['shadow'] = '7px -3px 5px rgba(88,88,88,0.7)';\n    }\n\n    if (opt_options['anchor'] == undefined) {\n      opt_options['anchor'] = RichMarkerPosition['BOTTOM'];\n    }\n\n    _this.setValues(options);\n\n    return _this;\n  }\n  /**\n   * Returns the current visibility state of the marker.\n   *\n   * @return {boolean} The visiblity of the marker.\n   */\n\n\n  _createClass(RichMarker, [{\n    key: 'getVisible',\n    value: function getVisible() {\n      return (\n        /** @type {boolean} */\n        this.get('visible')\n      );\n    }\n  }, {\n    key: 'setVisible',\n\n    /**\n     * Sets the visiblility state of the marker.\n     *\n     * @param {boolean} visible The visiblilty of the marker.\n     */\n    value: function setVisible(visible) {\n      this.set('visible', visible);\n    }\n  }, {\n    key: 'visible_changed',\n\n    /**\n     *  The visible changed event.\n     */\n    value: function visible_changed() {\n      if (this.ready_) {\n        this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';\n        this.draw();\n      }\n    }\n  }, {\n    key: 'setFlat',\n\n    /**\n     * Sets the marker to be flat.\n     *\n     * @param {boolean} flat If the marker is to be flat or not.\n     */\n    value: function setFlat(flat) {\n      this.set('flat', !!flat);\n    }\n  }, {\n    key: 'getFlat',\n\n    /**\n     * If the makrer is flat or not.\n     *\n     * @return {boolean} True the marker is flat.\n     */\n    value: function getFlat() {\n      return (\n        /** @type {boolean} */\n        this.get('flat')\n      );\n    }\n  }, {\n    key: 'getWidth',\n\n    /**\n     * Get the width of the marker.\n     *\n     * @return {Number} The width of the marker.\n     */\n    value: function getWidth() {\n      return (\n        /** @type {Number} */\n        this.get('width')\n      );\n    }\n  }, {\n    key: 'getHeight',\n\n    /**\n     * Get the height of the marker.\n     *\n     * @return {Number} The height of the marker.\n     */\n    value: function getHeight() {\n      return (\n        /** @type {Number} */\n        this.get('height')\n      );\n    }\n  }, {\n    key: 'setShadow',\n\n    /**\n     * Sets the marker's box shadow.\n     *\n     * @param {string} shadow The box shadow to set.\n     */\n    value: function setShadow(shadow) {\n      this.set('shadow', shadow);\n      this.flat_changed();\n    }\n  }, {\n    key: 'getShadow',\n\n    /**\n     * Gets the marker's box shadow.\n     *\n     * @return {string} The box shadow.\n     */\n    value: function getShadow() {\n      return (\n        /** @type {string} */\n        this.get('shadow')\n      );\n    }\n  }, {\n    key: 'flat_changed',\n\n    /**\n     * Flat changed event.\n     */\n    value: function flat_changed() {\n      if (!this.ready_) {\n        return;\n      }\n\n      this.markerWrapper_.style['boxShadow'] = this.markerWrapper_.style['webkitBoxShadow'] = this.markerWrapper_.style['MozBoxShadow'] = this.getFlat() ? '' : this.getShadow();\n    }\n  }, {\n    key: 'setZIndex',\n\n    /**\n     * Sets the zIndex of the marker.\n     *\n     * @param {Number} index The index to set.\n     */\n    value: function setZIndex(index) {\n      this.set('zIndex', index);\n    }\n  }, {\n    key: 'getZIndex',\n\n    /**\n     * Gets the zIndex of the marker.\n     *\n     * @return {Number} The zIndex of the marker.\n     */\n    value: function getZIndex() {\n      return (\n        /** @type {Number} */\n        this.get('zIndex')\n      );\n    }\n  }, {\n    key: 'zIndex_changed',\n\n    /**\n     * zIndex changed event.\n     */\n    value: function zIndex_changed() {\n      if (this.getZIndex() && this.ready_) {\n        this.markerWrapper_.style.zIndex = this.getZIndex();\n      }\n    }\n  }, {\n    key: 'getDraggable',\n\n    /**\n     * Whether the marker is draggable or not.\n     *\n     * @return {boolean} True if the marker is draggable.\n     */\n    value: function getDraggable() {\n      return (\n        /** @type {boolean} */\n        this.get('draggable')\n      );\n    }\n  }, {\n    key: 'setDraggable',\n\n    /**\n     * Sets the marker to be draggable or not.\n     *\n     * @param {boolean} draggable If the marker is draggable or not.\n     */\n    value: function setDraggable(draggable) {\n      this.set('draggable', !!draggable);\n    }\n  }, {\n    key: 'draggable_changed',\n\n    /**\n     * Draggable property changed callback.\n     */\n    value: function draggable_changed() {\n      if (this.ready_) {\n        if (this.getDraggable()) {\n          this.addDragging_(this.markerWrapper_);\n        } else {\n          this.removeDragListeners_();\n        }\n      }\n    }\n  }, {\n    key: 'getPosition',\n\n    /**\n     * Gets the postiton of the marker.\n     *\n     * @return {google.maps.LatLng} The position of the marker.\n     */\n    value: function getPosition() {\n      return (\n        /** @type {google.maps.LatLng} */\n        this.get('position')\n      );\n    }\n  }, {\n    key: 'setPosition',\n\n    /**\n     * Sets the position of the marker.\n     *\n     * @param {google.maps.LatLng} position The position to set.\n     */\n    value: function setPosition(position) {\n      this.set('position', position);\n    }\n  }, {\n    key: 'position_changed',\n\n    /**\n     * Position changed event.\n     */\n    value: function position_changed() {\n      this.draw();\n    }\n  }, {\n    key: 'getAnchor',\n\n    /**\n     * Gets the anchor.\n     *\n     * @return {google.maps.Size} The position of the anchor.\n     */\n    value: function getAnchor() {\n      return (\n        /** @type {google.maps.Size} */\n        this.get('anchor')\n      );\n    }\n  }, {\n    key: 'setAnchor',\n\n    /**\n     * Sets the anchor.\n     *\n     * @param {RichMarkerPosition|google.maps.Size} anchor The anchor to set.\n     */\n    value: function setAnchor(anchor) {\n      this.set('anchor', anchor);\n    }\n  }, {\n    key: 'anchor_changed',\n\n    /**\n     * Anchor changed event.\n     */\n    value: function anchor_changed() {\n      this.draw();\n    }\n  }, {\n    key: 'htmlToDocumentFragment_',\n\n    /**\n     * Converts a HTML string to a document fragment.\n     *\n     * @param {string} htmlString The HTML string to convert.\n     * @return {Node} A HTML document fragment.\n     * @private\n     */\n    value: function htmlToDocumentFragment_(htmlString) {\n      var tempDiv = document.createElement('DIV');\n      tempDiv.innerHTML = htmlString;\n\n      if (tempDiv.childNodes.length == 1) {\n        return (\n          /** @type {!Node} */\n          tempDiv.removeChild(tempDiv.firstChild)\n        );\n      } else {\n        var fragment = document.createDocumentFragment();\n\n        while (tempDiv.firstChild) {\n          fragment.appendChild(tempDiv.firstChild);\n        }\n\n        return fragment;\n      }\n    }\n  }, {\n    key: 'removeChildren_',\n\n    /**\n     * Removes all children from the node.\n     *\n     * @param {Node} node The node to remove all children from.\n     * @private\n     */\n    value: function removeChildren_(node) {\n      if (!node) {\n        return;\n      }\n\n      var child;\n\n      while (child = node.firstChild) {\n        node.removeChild(child);\n      }\n    }\n  }, {\n    key: 'setContent',\n\n    /**\n     * Sets the content of the marker.\n     *\n     * @param {string|Node} content The content to set.\n     */\n    value: function setContent(content) {\n      this.set('content', content);\n    }\n  }, {\n    key: 'getContent',\n\n    /**\n     * Get the content of the marker.\n     *\n     * @return {string|Node} The marker content.\n     */\n    value: function getContent() {\n      return (\n        /** @type {Node|string} */\n        this.get('content')\n      );\n    }\n  }, {\n    key: 'content_changed',\n\n    /**\n     * Sets the marker content and adds loading events to images\n     */\n    value: function content_changed() {\n      if (!this.markerContent_) {\n        // Marker content area doesnt exist.\n        return;\n      }\n\n      this.removeChildren_(this.markerContent_);\n      var content = this.getContent();\n\n      if (content) {\n        if (typeof content == 'string') {\n          content = content.replace(/^\\s*([\\S\\s]*)\\b\\s*$/, '$1');\n          content = this.htmlToDocumentFragment_(content);\n        }\n\n        this.markerContent_.appendChild(content);\n        var that = this;\n        var images = this.markerContent_.getElementsByTagName('IMG');\n\n        for (var i = 0, image; image = images[i]; i++) {\n          // By default, a browser lets a image be dragged outside of the browser,\n          // so by calling preventDefault we stop this behaviour and allow the image\n          // to be dragged around the map and now out of the browser and onto the\n          // desktop.\n          google.maps.event.addDomListener(image, 'mousedown', function (e) {\n            if (that.getDraggable()) {\n              if (e.preventDefault) {\n                e.preventDefault();\n              }\n\n              e.returnValue = false;\n            }\n          }); // Because we don't know the size of an image till it loads, add a\n          // listener to the image load so the marker can resize and reposition\n          // itself to be the correct height.\n\n          google.maps.event.addDomListener(image, 'load', function () {\n            that.draw();\n          });\n        }\n\n        google.maps.event.trigger(this, 'domready');\n      }\n\n      if (this.ready_) {\n        this.draw();\n      }\n    }\n  }, {\n    key: 'setCursor_',\n\n    /**\n     * Sets the cursor.\n     *\n     * @param {string} whichCursor What cursor to show.\n     * @private\n     */\n    value: function setCursor_(whichCursor) {\n      if (!this.ready_) {\n        return;\n      }\n\n      var cursor = '';\n\n      if (navigator.userAgent.indexOf('Gecko/') !== -1) {\n        // Moz has some nice cursors :)\n        if (whichCursor == 'dragging') {\n          cursor = '-moz-grabbing';\n        }\n\n        if (whichCursor == 'dragready') {\n          cursor = '-moz-grab';\n        }\n\n        if (whichCursor == 'draggable') {\n          cursor = 'pointer';\n        }\n      } else {\n        if (whichCursor == 'dragging' || whichCursor == 'dragready') {\n          cursor = 'move';\n        }\n\n        if (whichCursor == 'draggable') {\n          cursor = 'pointer';\n        }\n      }\n\n      if (this.markerWrapper_.style.cursor != cursor) {\n        this.markerWrapper_.style.cursor = cursor;\n      }\n    }\n  }, {\n    key: 'startDrag',\n\n    /**\n     * Start dragging.\n     *\n     * @param {Event} e The event.\n     */\n    value: function startDrag(e) {\n      if (!this.getDraggable()) {\n        return;\n      }\n\n      if (!this.dragging_) {\n        this.dragging_ = true;\n        var map = this.getMap();\n        this.mapDraggable_ = map.get('draggable');\n        map.set('draggable', false); // Store the current mouse position\n\n        this.mouseX_ = e.clientX;\n        this.mouseY_ = e.clientY;\n        this.setCursor_('dragready'); // Stop the text from being selectable while being dragged\n\n        this.markerWrapper_.style['MozUserSelect'] = 'none';\n        this.markerWrapper_.style['KhtmlUserSelect'] = 'none';\n        this.markerWrapper_.style['WebkitUserSelect'] = 'none';\n        this.markerWrapper_['unselectable'] = 'on';\n\n        this.markerWrapper_['onselectstart'] = function () {\n          return false;\n        };\n\n        this.addDraggingListeners_();\n        google.maps.event.trigger(this, 'dragstart');\n      }\n    }\n  }, {\n    key: 'stopDrag',\n\n    /**\n     * Stop dragging.\n     */\n    value: function stopDrag() {\n      if (!this.getDraggable()) {\n        return;\n      }\n\n      if (this.dragging_) {\n        this.dragging_ = false;\n        this.getMap().set('draggable', this.mapDraggable_);\n        this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null; // Allow the text to be selectable again\n\n        this.markerWrapper_.style['MozUserSelect'] = '';\n        this.markerWrapper_.style['KhtmlUserSelect'] = '';\n        this.markerWrapper_.style['WebkitUserSelect'] = '';\n        this.markerWrapper_['unselectable'] = 'off';\n\n        this.markerWrapper_['onselectstart'] = function () {};\n\n        this.removeDraggingListeners_();\n        this.setCursor_('draggable');\n        google.maps.event.trigger(this, 'dragend');\n        this.draw();\n      }\n    }\n  }, {\n    key: 'drag',\n\n    /**\n     * Handles the drag event.\n     *\n     * @param {Event} e The event.\n     */\n    value: function drag(e) {\n      if (!this.getDraggable() || !this.dragging_) {\n        // This object isn't draggable or we have stopped dragging\n        this.stopDrag();\n        return;\n      }\n\n      var dx = this.mouseX_ - e.clientX;\n      var dy = this.mouseY_ - e.clientY;\n      this.mouseX_ = e.clientX;\n      this.mouseY_ = e.clientY;\n      var left = parseInt(this.markerWrapper_.style['left'], 10) - dx;\n      var top = parseInt(this.markerWrapper_.style['top'], 10) - dy;\n      this.markerWrapper_.style['left'] = left + 'px';\n      this.markerWrapper_.style['top'] = top + 'px';\n      var offset = this.getOffset_(); // Set the position property and adjust for the anchor offset\n\n      var point = new google.maps.Point(left - offset.width, top - offset.height);\n      var projection = this.getProjection();\n      this.setPosition(projection.fromDivPixelToLatLng(point));\n      this.setCursor_('dragging');\n      google.maps.event.trigger(this, 'drag');\n    }\n  }, {\n    key: 'removeDragListeners_',\n\n    /**\n     * Removes the drag listeners associated with the marker.\n     *\n     * @private\n     */\n    value: function removeDragListeners_() {\n      if (this.draggableListener_) {\n        google.maps.event.removeListener(this.draggableListener_);\n        delete this.draggableListener_;\n      }\n\n      this.setCursor_('');\n    }\n  }, {\n    key: 'addDragging_',\n\n    /**\n     * Add dragability events to the marker.\n     *\n     * @param {Node} node The node to apply dragging to.\n     * @private\n     */\n    value: function addDragging_(node) {\n      if (!node) {\n        return;\n      }\n\n      var that = this;\n      this.draggableListener_ = google.maps.event.addDomListener(node, 'mousedown', function (e) {\n        that.startDrag(e);\n      });\n      this.setCursor_('draggable');\n    }\n  }, {\n    key: 'addDraggingListeners_',\n\n    /**\n     * Add dragging listeners.\n     *\n     * @private\n     */\n    value: function addDraggingListeners_() {\n      var that = this;\n\n      if (this.markerWrapper_.setCapture) {\n        this.markerWrapper_.setCapture(true);\n        this.draggingListeners_ = [google.maps.event.addDomListener(this.markerWrapper_, 'mousemove', function (e) {\n          that.drag(e);\n        }, true), google.maps.event.addDomListener(this.markerWrapper_, 'mouseup', function () {\n          that.stopDrag();\n          that.markerWrapper_.releaseCapture();\n        }, true)];\n      } else {\n        this.draggingListeners_ = [google.maps.event.addDomListener(window, 'mousemove', function (e) {\n          that.drag(e);\n        }, true), google.maps.event.addDomListener(window, 'mouseup', function () {\n          that.stopDrag();\n        }, true)];\n      }\n    }\n  }, {\n    key: 'removeDraggingListeners_',\n\n    /**\n     * Remove dragging listeners.\n     *\n     * @private\n     */\n    value: function removeDraggingListeners_() {\n      if (this.draggingListeners_) {\n        for (var i = 0, listener; listener = this.draggingListeners_[i]; i++) {\n          google.maps.event.removeListener(listener);\n        }\n\n        this.draggingListeners_.length = 0;\n      }\n    }\n  }, {\n    key: 'getOffset_',\n\n    /**\n     * Get the anchor offset.\n     *\n     * @return {google.maps.Size} The size offset.\n     * @private\n     */\n    value: function getOffset_() {\n      var anchor = this.getAnchor();\n\n      if ((typeof anchor === 'undefined' ? 'undefined' : _typeof(anchor)) == 'object') {\n        return (\n          /** @type {google.maps.Size} */\n          anchor\n        );\n      }\n\n      var offset = new google.maps.Size(0, 0);\n\n      if (!this.markerContent_) {\n        return offset;\n      }\n\n      var width = this.markerContent_.offsetWidth;\n      var height = this.markerContent_.offsetHeight;\n\n      switch (anchor) {\n        case RichMarkerPosition['TOP_LEFT']:\n          break;\n\n        case RichMarkerPosition['TOP']:\n          offset.width = -width / 2;\n          break;\n\n        case RichMarkerPosition['TOP_RIGHT']:\n          offset.width = -width;\n          break;\n\n        case RichMarkerPosition['LEFT']:\n          offset.height = -height / 2;\n          break;\n\n        case RichMarkerPosition['MIDDLE']:\n          offset.width = -width / 2;\n          offset.height = -height / 2;\n          break;\n\n        case RichMarkerPosition['RIGHT']:\n          offset.width = -width;\n          offset.height = -height / 2;\n          break;\n\n        case RichMarkerPosition['BOTTOM_LEFT']:\n          offset.height = -height;\n          break;\n\n        case RichMarkerPosition['BOTTOM']:\n          offset.width = -width / 2;\n          offset.height = -height;\n          break;\n\n        case RichMarkerPosition['BOTTOM_RIGHT']:\n          offset.width = -width;\n          offset.height = -height;\n          break;\n      }\n\n      return offset;\n    }\n  }, {\n    key: 'onAdd',\n\n    /**\n     * Adding the marker to a map.\n     * Implementing the interface.\n     */\n    value: function onAdd() {\n      if (!this.markerWrapper_) {\n        this.markerWrapper_ = document.createElement('DIV');\n        this.markerWrapper_.style['position'] = 'absolute';\n      }\n\n      if (this.getZIndex()) {\n        this.markerWrapper_.style['zIndex'] = this.getZIndex();\n      }\n\n      this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';\n\n      if (!this.markerContent_) {\n        this.markerContent_ = document.createElement('DIV');\n        this.markerWrapper_.appendChild(this.markerContent_);\n        var that = this;\n        google.maps.event.addDomListener(this.markerContent_, 'click', function (e) {\n          google.maps.event.trigger(that, 'click', e);\n        });\n        google.maps.event.addDomListener(this.markerContent_, 'mouseover', function (e) {\n          google.maps.event.trigger(that, 'mouseover', e);\n        });\n        google.maps.event.addDomListener(this.markerContent_, 'mouseout', function (e) {\n          google.maps.event.trigger(that, 'mouseout', e);\n        });\n      }\n\n      this.ready_ = true;\n      this.content_changed();\n      this.flat_changed();\n      this.draggable_changed();\n      var panes = this.getPanes();\n\n      if (panes) {\n        panes.overlayMouseTarget.appendChild(this.markerWrapper_);\n      }\n\n      google.maps.event.trigger(this, 'ready');\n    }\n  }, {\n    key: 'draw',\n\n    /**\n     * Impelementing the interface.\n     */\n    value: function draw() {\n      if (!this.ready_ || this.dragging_) {\n        return;\n      }\n\n      var projection = this.getProjection();\n\n      if (!projection) {\n        // The map projection is not ready yet so do nothing\n        return;\n      }\n\n      var latLng =\n      /** @type {google.maps.LatLng} */\n      this.get('position');\n      var pos = projection.fromLatLngToDivPixel(latLng);\n      var offset = this.getOffset_();\n      this.markerWrapper_.style['top'] = pos.y + offset.height + 'px';\n      this.markerWrapper_.style['left'] = pos.x + offset.width + 'px';\n      var height = this.markerContent_.offsetHeight;\n      var width = this.markerContent_.offsetWidth;\n\n      if (width != this.get('width')) {\n        this.set('width', width);\n      }\n\n      if (height != this.get('height')) {\n        this.set('height', height);\n      }\n    }\n  }, {\n    key: 'onRemove',\n\n    /**\n     * Removing a marker from the map.\n     * Implementing the interface.\n     */\n    value: function onRemove() {\n      if (this.markerWrapper_ && this.markerWrapper_.parentNode) {\n        this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);\n      }\n\n      this.removeDragListeners_();\n    }\n  }]);\n\n  return RichMarker;\n}(google.maps.OverlayView);\n/**\n * RichMarker Anchor positions\n * @enum {number}\n */\n\n\nvar RichMarkerPosition = exports.RichMarkerPosition = {\n  'TOP_LEFT': 1,\n  'TOP': 2,\n  'TOP_RIGHT': 3,\n  'LEFT': 4,\n  'MIDDLE': 5,\n  'RIGHT': 6,\n  'BOTTOM_LEFT': 7,\n  'BOTTOM': 8,\n  'BOTTOM_RIGHT': 9\n};","map":null,"metadata":{},"sourceType":"script"}